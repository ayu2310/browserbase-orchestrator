"""Autonomous Browserbase orchestrator built on MCP + OpenAI."""
from __future__ import annotations

import asyncio
import json
import textwrap
import uuid
from dataclasses import dataclass, field
from typing import Any, Awaitable, Callable, Dict, List, Optional, Tuple

from openai import OpenAI

from config import OPENAI_API_KEY, OPENAI_MODEL
from database import get_flow_state, init_database, save_flow_state
from mcp_client import MCPClient


ALLOWED_TOOLS = [
    "browserbase_session_create",
    "browserbase_session_close",
    "browserbase_stagehand_navigate",
    "browserbase_stagehand_observe",
    "browserbase_stagehand_act",
    "browserbase_stagehand_extract",
    "browserbase_stagehand_screenshot",
    "browserbase_stagehand_get_url",
    "browserbase_list_cached_actions",
]


@dataclass
class PlannerDecision:
    """Structured plan generated by the LLM."""

    status: str
    tool: Optional[str] = None
    arguments: Dict[str, Any] = field(default_factory=dict)
    response: str = ""
    reasoning: str = ""


class Planner:
    """LLM-based planner that decides which MCP tool to call next."""

    def __init__(self) -> None:
        if not OPENAI_API_KEY:
            raise ValueError("OPENAI_API_KEY is required for orchestrator planner")
        self.client = OpenAI(api_key=OPENAI_API_KEY)

    async def decide(
        self,
        task_prompt: str,
        history: List[Dict[str, Any]],
        state_snapshot: str,
    ) -> PlannerDecision:
        """Call GPT-4o to choose the next MCP tool invocation."""

        prompt = textwrap.dedent(
            f"""
            You orchestrate Browserbase Stagehand tools via the Model Context Protocol (MCP).
            
            CRITICAL: The MCP server is STATELESS. Every tool call MUST include the latest flowState 
            to maintain the same browser session. If you don't pass flowState, a NEW session is created 
            and you'll see a blank screen.
            
            Task: {task_prompt}
            Current state: {state_snapshot}
            
            IMPORTANT: Check the current state above. If it shows a session exists, you MUST use that 
            session. Do NOT create a new session if one already exists.

            Recent actions (last 6):
            {json.dumps(history[-6:], indent=2) if history else "[]"}

            Available tools: {", ".join(ALLOWED_TOOLS)}

            TOOL SCHEMAS (REQUIRED PARAMETERS):
            
            IMPORTANT: flowState is automatically attached by the system, but you MUST still include it in your arguments 
            for clarity. The system will merge it with your arguments.
            
            - `browserbase_session_create`: 
              Arguments: {{"flowState": {{"cacheKey": "your-cache-key"}}}}
              Note: Creates a new browser session. Use ONLY ONCE at the start.
            
            - `browserbase_session_close`: 
              Arguments: {{"flowState": <current flowState>}}
              Note: Closes the browser session. Call this when task is complete.
            
            - `browserbase_stagehand_navigate`: 
              Arguments: {{"url": "https://example.com", "flowState": <current flowState>}}
              Required: url (string) - the URL to navigate to
              Note: Sets the startingUrl in flowState. Use this to go to a website.
            
            - `browserbase_stagehand_observe`: 
              Arguments: {{"instruction": "Find the login button", "returnAction": true, "flowState": <current flowState>}}
              Required: instruction (string) - what element to find
              Optional: returnAction (boolean) - set to true to get actionable selectors
              Note: Use SPARINGLY (max 2-3 times per task). Only when you need a specific clickable element.
            
            - `browserbase_stagehand_act`: 
              Arguments (Mode 1 - Natural Language): {{"action": "Click the submit button", "flowState": <current flowState>}}
              Arguments (Mode 2 - Deterministic): {{"observation": {{"selector": "...", "method": "click"}}, "flowState": <current flowState>}}
              Required: EITHER "action" (string) OR "observation" (object from observe)
              Note: Use for ALL browser interactions (click, type, scroll, fill forms, etc.)
              Examples:
                - Click: {{"action": "Click the login button"}}
                - Type: {{"action": "Type 'search term' into the search box"}}
                - Scroll: {{"action": "Scroll down to see more products"}}
                - Fill: {{"action": "Fill the email field with 'user@example.com'"}}
            
            - `browserbase_stagehand_extract`: 
              Arguments: {{"instruction": "Extract the top 5 products with their names, descriptions, and links", "flowState": <current flowState>}}
              Required: instruction (string) - detailed extraction instructions
              Note: Use this to extract structured data from pages. More reliable than observe for reading data.
              Example: {{"instruction": "Extract the top 5 trending AI products with their names, descriptions, and what makes them trending"}}
            
            - `browserbase_stagehand_screenshot`: 
              Arguments: {{"flowState": <current flowState>}}
              Note: Captures a screenshot of the current page state.
            
            - `browserbase_stagehand_get_url`: 
              Arguments: {{"flowState": <current flowState>}}
              Note: Returns the current URL of the page.

            CRITICAL TOOL USAGE RULES:
            
            1. SESSION MANAGEMENT:
               - Use `browserbase_session_create` ONLY ONCE at the start if no session exists.
               - Use `browserbase_session_close` at the END when task is complete.
            
            2. NAVIGATION:
               - Use `browserbase_stagehand_navigate` to go to URLs (sets `startingUrl`).
               - Use `browserbase_stagehand_get_url` to check current URL if needed.
            
            3. OBSERVE (Use VERY SPARINGLY - only when you MUST find a specific clickable element):
               - Use `browserbase_stagehand_observe` ONLY when you need to find a SPECIFIC element to CLICK.
               - Set `returnAction=true` to get actionable selectors.
               - DO NOT observe to "see what's on the page" - use extract or natural language actions instead.
               - DO NOT observe repeatedly - if observe returns empty, try extract or natural language actions.
               - DO NOT observe more than 2-3 times total - if it fails, switch to extract or natural language.
               - After observing, immediately use the returned selectors in `browserbase_stagehand_act`.
               - If you need to READ or EXTRACT data, use `browserbase_stagehand_extract` directly - don't observe first.
            
            4. ACT (Use for ALL interactions):
               - Use `browserbase_stagehand_act` for ALL user interactions:
                 * Clicking: "Click the login button" or use observation with method "click"
                 * Typing: "Type 'search term' into the search box" or use observation with method "fill"
                 * Scrolling: "Scroll down to see more products"
                 * Filling forms: "Fill the email field with 'user@example.com'"
                 * Any other browser action
               - Prefer natural language actions when you know what to do: `{{"action": "Click the submit button"}}`
               - Use deterministic observations when you have them: `{{"observation": {{...}}, "flowState": ...}}`
               - You can combine multiple actions in natural language: "Scroll down and click the 'Load More' button"
            
            5. DATA EXTRACTION (PREFERRED over observe for reading data):
               - Use `browserbase_stagehand_extract` DIRECTLY to extract data - you don't need to observe first.
               - Provide clear, specific extraction instructions: "Extract the top 5 trending AI products with their names, descriptions, and links"
               - Extract can read and parse page content without needing to observe elements first.
               - If you need to scroll or interact before extracting, use natural language actions: "Scroll down to see more products, then extract the top 5 AI products"
               - Extract is more reliable than observe for getting text/data from pages.
            
            6. VERIFICATION:
               - Use `browserbase_stagehand_screenshot` to capture page state (optional, for debugging).
               - Use `browserbase_stagehand_get_url` to verify navigation.
            
            7. EFFICIENCY - MINIMIZE OBSERVE, MAXIMIZE EXTRACT AND NATURAL LANGUAGE:
               - PREFER extract over observe for reading data: "Extract the top 5 products" instead of observe then extract.
               - PREFER natural language actions: "Scroll down to see trending products" instead of observe.
               - Only observe when you MUST find a specific button/link to click that you can't describe naturally.
               - If observe returns empty ONCE, immediately switch to extract or natural language - don't retry observe.
               - Maximum 2-3 observe calls per task - if they fail, use extract or natural language actions.
               - For ProductHunt: Use "Extract the top 5 trending AI products with names and descriptions" directly.
               - Combine actions: "Scroll down and extract products" instead of observe+act+extract.
            
            8. COMPLETION - MANDATORY SESSION CLOSURE + FINISH:
               - When the task is COMPLETE (you have the required information), you MUST:
                 1. First call `browserbase_session_close` with flowState to close the session.
                 2. Then IMMEDIATELY reply with status `finish` (do NOT call another tool after closing).
               - After calling `browserbase_session_close`, the NEXT decision MUST be status `finish`.
               - DO NOT call any other tools after closing the session.
               - The finish summary should clearly state what was accomplished.
               - Example: Close session â†’ Next decision: {{"status": "finish", "response": "Task completed: ..."}}

            Respond only with valid JSON following this schema:
            {{
                "status": "call_tool" | "finish",
                "tool": "<name when status=call_tool>",
                "arguments": {{... arguments object ...}},
                "response": "<final summary when status=finish>",
                "reasoning": "<short explanation>"
            }}
            """
        ).strip()

        def _call_llm() -> str:
            response = self.client.chat.completions.create(
                model=OPENAI_MODEL,
                temperature=0.2,
                response_format={"type": "json_object"},
                messages=[
                    {
                        "role": "system",
                        "content": "You are a precise automation planner. Follow the tool usage rules strictly. CRITICAL RULES:\n1. You MUST include ALL required parameters in the 'arguments' object for each tool call.\n2. For browserbase_stagehand_extract, you MUST include 'instruction' parameter (string).\n3. For browserbase_stagehand_navigate, you MUST include 'url' parameter (string).\n4. For browserbase_stagehand_observe, you MUST include 'instruction' parameter (string).\n5. For browserbase_stagehand_act, you MUST include EITHER 'action' (string) OR 'observation' (object).\n6. flowState will be automatically merged with your arguments, but still include it for clarity.\n7. Avoid unnecessary observe calls (max 2-3 per task).\n8. Always close sessions when finishing.\n9. Always output valid JSON.",
                    },
                    {"role": "user", "content": prompt},
                ],
            )
            return response.choices[0].message.content or "{}"

        raw = await asyncio.to_thread(_call_llm)
        try:
            data = json.loads(raw)
        except json.JSONDecodeError as exc:
            raise ValueError(f"Planner returned invalid JSON: {raw}") from exc

        status = data.get("status", "").lower()
        decision = PlannerDecision(
            status=status,
            tool=data.get("tool"),
            arguments=data.get("arguments") or {},
            response=data.get("response", ""),
            reasoning=data.get("reasoning", ""),
        )

        if decision.status == "call_tool" and decision.tool not in ALLOWED_TOOLS:
            raise ValueError(f"Planner selected unsupported tool: {decision.tool}")

        return decision


@dataclass
class OrchestratorResult:
    """Structured orchestrator output."""

    cache_key: str
    mode: str
    summary: str
    steps: List[Dict[str, Any]]
    flow_state: Optional[Dict[str, Any]]


class OrchestratorAgent:
    """Coordinates the MCP client + LLM planner into an autonomous agent."""

    def __init__(
        self,
        task_prompt: str,
        cache_key: Optional[str] = None,
        mode: str = "autonomous",
        max_steps: int = 30,
        on_update: Optional[Callable[[Dict[str, Any]], Awaitable[None]]] = None,
    ) -> None:
        init_database()
        self.task_prompt = task_prompt.strip()
        self.mode = mode
        self.max_steps = max_steps
        self.cache_key = cache_key or f"flow-{uuid.uuid4().hex}"
        self.history: List[Dict[str, Any]] = []
        self.planner = Planner()
        self.mcp_client = MCPClient(cache_key=self.cache_key)
        self.on_update = on_update
        self._hydrate_existing_state()

    def _hydrate_existing_state(self) -> None:
        existing = get_flow_state(self.cache_key)
        if existing:
            self.mcp_client.hydrate(existing["flow_state"])

    async def run(self) -> OrchestratorResult:
        """Run autonomous orchestration."""
        if self.mode == "replay":
            return await self._run_replay()

        await self._ensure_session()
        summary = "Maximum step count reached without finish signal."

        for step in range(1, self.max_steps + 1):
            # Get LLM decision
            decision = await self.planner.decide(
                self.task_prompt,
                self.history,
                self.mcp_client.describe_state(),
            )

            # Stream LLM reasoning
            if self.on_update:
                await self.on_update({
                    "type": "reasoning",
                    "step": step,
                    "reasoning": decision.reasoning,
                    "tool": decision.tool,
                    "status": decision.status,
                })

            if decision.status == "finish":
                summary = decision.response or "Task marked as complete."
                
                # Close session before finishing
                try:
                    await self.mcp_client.invoke("browserbase_session_close", {})
                    self._persist_flow_state()
                    if self.on_update:
                        await self.on_update({
                            "type": "session_closed",
                            "message": "Browser session closed",
                        })
                except Exception as e:
                    # Session close is best effort
                    pass
                
                if self.on_update:
                    await self.on_update({
                        "type": "complete",
                        "summary": summary,
                    })
                break

            if decision.status != "call_tool" or not decision.tool:
                summary = "Planner could not decide on a tool; stopping."
                if self.on_update:
                    await self.on_update({
                        "type": "error",
                        "message": summary,
                    })
                break

            # Execute tool
            result = await self._invoke_tool(decision.tool, decision.arguments)
            
            # If session was closed, next decision should be finish
            if decision.tool == "browserbase_session_close":
                # Wait for next decision which should be finish
                next_decision = await self.planner.decide(
                    self.task_prompt,
                    self.history,
                    self.mcp_client.describe_state(),
                )
                if next_decision.status == "finish":
                    summary = next_decision.response or "Task completed."
                    if self.on_update:
                        await self.on_update({
                            "type": "complete",
                            "summary": summary,
                        })
                    break
            
            # Take screenshot after each action (skip if tool was already screenshot)
            screenshot_data = None
            if decision.tool != "browserbase_stagehand_screenshot":
                try:
                    screenshot_result = await self.mcp_client.invoke("browserbase_stagehand_screenshot", {})
                    screenshot_data = self._extract_screenshot(screenshot_result)
                    # Update flowState after screenshot
                    self._persist_flow_state()
                except Exception as e:
                    # Screenshot is optional, continue if it fails
                    pass
            else:
                # If screenshot was the tool, extract it from result
                screenshot_data = self._extract_screenshot(result)

            self._record_step(step, decision, result)
            
            # Stream step update with flowState and screenshot
            if self.on_update:
                await self.on_update({
                    "type": "step",
                    "step": step,
                    "tool": decision.tool,
                    "result": self._summarize_result(result),
                    "flow_state": self.mcp_client.flow_state,
                    "screenshot": screenshot_data,
                })

        # Ensure session is closed
        try:
            if self.mcp_client.has_active_session:
                await self.mcp_client.invoke("browserbase_session_close", {})
                self._persist_flow_state()
        except Exception:
            pass
        
        # Final cleanup - ensure session is closed
        try:
            if self.mcp_client.has_active_session:
                await self.mcp_client.invoke("browserbase_session_close", {})
                self._persist_flow_state()
                if self.on_update:
                    await self.on_update({
                        "type": "session_closed",
                        "message": "Browser session closed",
                    })
        except Exception:
            pass
        
        await self.mcp_client.close()
        return OrchestratorResult(
            cache_key=self.cache_key,
            mode=self.mode,
            summary=summary,
            steps=self.history,
            flow_state=self.mcp_client.flow_state,
        )

    async def _run_replay(self) -> OrchestratorResult:
        """Replay previously stored flowState."""
        stored = get_flow_state(self.cache_key)
        if not stored:
            raise ValueError(
                f"No stored flowState found for cache_key '{self.cache_key}'. "
                "Run an autonomous session first."
            )

        self.mcp_client.hydrate(stored["flow_state"])
        result = await self.mcp_client.invoke(
            "browserbase_stagehand_act",
            {"replayState": stored["flow_state"]},
        )
        summary = self._summarize_result(result)
        
        # Close session after replay
        try:
            await self.mcp_client.invoke("browserbase_session_close", {})
        except Exception:
            pass
        
        await self.mcp_client.close()
        return OrchestratorResult(
            cache_key=self.cache_key,
            mode="replay",
            summary=summary or "Replay executed.",
            steps=[
                {
                    "step": 1,
                    "tool": "browserbase_stagehand_act",
                    "arguments": {"replayState": "stored"},
                    "result": summary,
                    "success": True,
                }
            ],
            flow_state=stored["flow_state"],
        )

    async def _ensure_session(self) -> None:
        """Ensure a Browserbase session is created."""
        if self.mcp_client.has_active_session:
            return
        await self.mcp_client.invoke(
            "browserbase_session_create",
            {"flowState": {"cacheKey": self.cache_key}},
        )
        self._persist_flow_state()

    async def _invoke_tool(
        self, tool: str, arguments: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Invoke MCP tool and persist resulting flowState."""
        arguments = arguments or {}
        result = await self.mcp_client.invoke(tool, arguments)
        self._persist_flow_state()
        return result

    def _persist_flow_state(self) -> None:
        if self.mcp_client.flow_state:
            save_flow_state(
                cache_key=self.cache_key,
                prompt=self.task_prompt,
                flow_state=self.mcp_client.flow_state,
            )

    def _record_step(
        self,
        step_number: int,
        decision: PlannerDecision,
        result: Dict[str, Any],
    ) -> None:
        summary = self._summarize_result(result)
        self.history.append(
            {
                "step": step_number,
                "tool": decision.tool,
                "arguments": decision.arguments,
                "result": summary,
                "reasoning": decision.reasoning,
            }
        )

    def _summarize_result(self, result: Dict[str, Any]) -> str:
        """Return a human-friendly summary of the MCP response."""
        if not result:
            return "Empty response"

        text_chunks: List[str] = []
        if "message" in result and isinstance(result["message"], str):
            text_chunks.append(result["message"])

        content = result.get("content")
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict):
                    if item.get("type") == "text":
                        text_chunks.append(str(item.get("text", "")))
                    elif item.get("type") == "json":
                        try:
                            text_chunks.append(json.dumps(item.get("json"), ensure_ascii=False))
                        except (TypeError, ValueError):
                            pass

        if not text_chunks:
            text_chunks.append(json.dumps(result, ensure_ascii=False)[:500])

        summary = " ".join(chunk.strip() for chunk in text_chunks if chunk).strip()
        return summary[:800]

    def _extract_screenshot(self, result: Dict[str, Any]) -> Optional[str]:
        """Extract screenshot data from MCP response."""
        if not result:
            return None
        
        # Try to find screenshot in various response formats
        content = result.get("content")
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict):
                    # Check for image data
                    if item.get("type") == "image" and "data" in item:
                        return item.get("data")
                    # Check for base64 encoded image
                    if "image" in item or "screenshot" in item:
                        data = item.get("data") or item.get("image") or item.get("screenshot")
                        if data:
                            return data
        
        # Check raw response
        raw = result.get("raw", {})
        if isinstance(raw, dict):
            if "screenshot" in raw:
                return raw["screenshot"]
            if "image" in raw:
                return raw["image"]
        
        return None


__all__ = ["OrchestratorAgent", "OrchestratorResult"]


